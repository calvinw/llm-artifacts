<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenRouter API With Artifacts Window</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Add MathJax -->
 
    <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$', '$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="panel" id="panel1">
            <div class="panel-header">Settings</div>
            <div class="panel-content">
                <div id="settingsForm" class="settings-form">
                    <div class="settings-group">
                        <label for="apiKey" class="settings-label">API Key:</label>
                        <input type="password" id="apiKey" class="settings-input" placeholder="Enter your API key">
                    </div>
                    <div class="settings-group">
                        <label for="model" class="settings-label">Model:</label>
                        <input type="text" id="model" class="settings-input" placeholder="Enter model name">
                    </div>
                    <div class="settings-group">
                        <label class="settings-label">Render Mode:</label>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="renderMode" value="text"> Text
                            </label>
                            <label>
                                <input type="radio" name="renderMode" value="markdown" checked> Markdown
                            </label>
                        </div>
                    </div>
                </div>
                <div id="settingsError" class="error-message"></div>
            </div>
        </div>
        <div class="divider" id="divider1"></div>
        <div class="panel" id="panel2">
            <div class="panel-header">
                Chat
                <button id="clearChatButton" class="clear-chat-button">Clear Chat Messages</button>
            </div>
            <div class="system-prompt-container">
                <label for="systemPrompt" class="system-prompt-label">System Prompt:</label>
                <textarea id="systemPrompt" class="system-prompt" placeholder="Enter optional system prompt here"></textarea>
            </div>
            <div class="chat-container" id="chatContainer"></div>
            <div class="chat-input-container">
                <div class="chat-input-wrapper">
                    <textarea id="chatInput" class="chat-input" placeholder="Send a message" rows="3"></textarea>
                    <button id="chatButton" class="chat-button">&#x2798;</button>
                </div>
            </div>
        </div>
        <div class="divider" id="divider2"></div>
        <div class="panel" id="panel3">
            <div class="panel-header">Content</div>
            <div class="panel-content">
                <div class="content-item">
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let isDragging = false;
            let startX, startWidth1, startWidth2, divider;

            document.querySelectorAll('.divider').forEach(div => {
                div.addEventListener('mousedown', function(e) {
                    isDragging = true;
                    divider = e.target;
                    startX = e.clientX;
                    
                    const prevPanel = divider.previousElementSibling;
                    const nextPanel = divider.nextElementSibling;

                    startWidth1 = prevPanel.offsetWidth;
                    startWidth2 = nextPanel.offsetWidth;

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            });

            function onMouseMove(e) {
                if (!isDragging) return;

                const dx = e.clientX - startX;
                const prevPanel = divider.previousElementSibling;
                const nextPanel = divider.nextElementSibling;

                const newWidth1 = startWidth1 + dx;
                const newWidth2 = startWidth2 - dx;

                if (newWidth1 > 50 && newWidth2 > 50) {
                    prevPanel.style.width = `${newWidth1}px`;
                    nextPanel.style.width = `${newWidth2}px`;
                }
            }

            function onMouseUp() {
                isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }

            const chatContainer = document.getElementById('chatContainer');
            const chatInput = document.getElementById('chatInput');
            const chatButton = document.getElementById('chatButton');
            const apiKeyInput = document.getElementById('apiKey');
            const modelInput = document.getElementById('model');
            const settingsError = document.getElementById('settingsError');
            const renderModeRadios = document.querySelectorAll('input[name="renderMode"]');

            const clearChatButton = document.getElementById('clearChatButton');
            const systemPromptInput = document.getElementById('systemPrompt');

            let messageHistory = [];

            // Set default values
            const defaultApiKey = '';
            const defaultModel = 'openai/gpt-4o-mini';
            //const defaultModel = 'google/gemini-flash-1.5-8b';

            // Populate fields only if they're empty
            if (!apiKeyInput.value) {
                apiKeyInput.value = defaultApiKey;
            }

            if (!modelInput.value) {
                modelInput.value = defaultModel;
            }

            let renderMode = 'markdown';  // Set default render mode to markdown

            renderModeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    renderMode = this.value;
                    rerenderMessages();
                });
            });

            chatButton.addEventListener('click', sendMessage);

            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            clearChatButton.addEventListener('click', clearChatMessages);

            function clearChatMessages() {
                chatContainer.innerHTML = '';
                messageHistory = [];
            }

            async function sendMessage() {
                let userMessage = chatInput.value.trim();
                if (userMessage) {
                    if (!apiKeyInput.value.trim() || !modelInput.value.trim()) {
                        settingsError.textContent = 'Please enter API key and model in the settings panel.';
                        return;
                    }
                    
                    addMessage(userMessage, 'user');
                    
                    let currentMessageHistory = [];
                    
                    // Add system prompt if it's not empty
                    const systemPrompt = systemPromptInput.value.trim();
                    if (systemPrompt) {
                        currentMessageHistory.push({ role: "system", content: systemPrompt });
                    }
                    
                    // Add user message
                    currentMessageHistory.push({ role: "user", content: userMessage });
                    
                    // Add previous messages
                    currentMessageHistory = currentMessageHistory.concat(
                        messageHistory.map(msg => ({ role: msg.role, content: msg.rawContent }))
                    );

                    chatInput.value = '';

                    try {
                        const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                            method: "POST",
                            headers: {
                                "Authorization": `Bearer ${apiKeyInput.value.trim()}`,
                                "Content-Type": "application/json"
                            },
                            body: JSON.stringify({
                                "model": modelInput.value.trim(),
                                "messages": currentMessageHistory,
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const data = await response.json();
                        let aiMessage = data.choices[0].message.content;
                        
                        addMessage(aiMessage, 'bot');
                    } catch (error) {
                        console.error('Error:', error);
                        settingsError.textContent = 'Error calling the API. Please check your settings and try again.';
                    }
                }
            }

            function addMessage(message, sender) {
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message');
                messageElement.classList.add(sender === 'user' ? 'user-message' : 'bot-message');

                const messageContent = document.createElement('div');
                messageContent.classList.add('message-content');

                const iconElement = document.createElement('div');
                iconElement.classList.add('message-icon');
                iconElement.textContent = sender === 'user' ? 'Human:' : 'AI:';

                const textElement = document.createElement('div');
                textElement.classList.add('message-text');
                
                const renderedMessage = renderMessageText(message);
                textElement.innerHTML = renderedMessage;

                messageContent.appendChild(iconElement);
                messageContent.appendChild(textElement);
                messageElement.appendChild(messageContent);

                chatContainer.appendChild(messageElement);
                chatContainer.scrollTop = chatContainer.scrollHeight;

                messageHistory.push({
                    role: sender === 'user' ? 'user' : 'assistant',
                    rawContent: message
                });

                // Only typeset if in Markdown mode
                if (renderMode === 'markdown') {
                    MathJax.typesetPromise([textElement]).catch((err) => console.error(err.message));
                }
            }

            function preprocessMessageForMath(message) {
                // Escape \( and \) for inline math
                message = message.replace(/\\\(/g, '\\\\(').replace(/\\\)/g, '\\\\)');

                // Escape \\[ and \\] for display math
                message = message.replace(/\\\[/g, '\\\\[').replace(/\\\]/g, '\\\\]');

                return message;
            }

            function renderMessageText(message) {
                if (renderMode === 'text') {
                    // Preserve new lines and escape HTML
                    return escapeHtml(message).replace(/\n/g, '<br>');
                } else {
                    const markedOptions = {
                        breaks: true,
                        gfm: true
                    };

                   // Step 1: Preprocess the LLM response to escape LaTeX delimiters
                    const processedMessage = preprocessMessageForMath(message);
                    
                    // Step 2: Render the preprocessed message with Markdown
                    let renderedMessage = marked.parse(processedMessage, markedOptions);
                    return renderedMessage;
                }
            }

            function escapeHtml(unsafe) {
                return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            }

            function rerenderMessages() {
                chatContainer.innerHTML = ''; // Clear the chat container
                messageHistory.forEach((msg) => {
                    const messageElement = document.createElement('div');
                    messageElement.classList.add('chat-message');
                    messageElement.classList.add(msg.role === 'user' ? 'user-message' : 'bot-message');

                    const messageContent = document.createElement('div');
                    messageContent.classList.add('message-content');

                    const iconElement = document.createElement('div');
                    iconElement.classList.add('message-icon');
                    iconElement.textContent = msg.role === 'user' ? 'Human:' : 'AI:';

                    const textElement = document.createElement('div');
                    textElement.classList.add('message-text');
                    
                    const renderedMessage = renderMessageText(msg.rawContent);
                    textElement.innerHTML = renderedMessage;

                    messageContent.appendChild(iconElement);
                    messageContent.appendChild(textElement);
                    messageElement.appendChild(messageContent);

                    chatContainer.appendChild(messageElement);

                    // Only typeset if in Markdown mode
                    if (renderMode === 'markdown') {
                        MathJax.typesetPromise([textElement]).catch((err) => console.error(err.message));
                    }
                });
            }

            window.addEventListener('load', function () {
                MathJax.startup.promise.then(() => {
                    MathJax.typesetPromise().catch((err) => console.error(err.message));
                });
            });
        });
    </script>
</body>
</html>
